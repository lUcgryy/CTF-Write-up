
# Written by Anirudh Anand (lucif3r) : email - anirudh@anirudhanand.com   
# This program will help to decrypt cipher text to plain text if you have
# more than 1 cipher text encrypted with same Modulus (N) but different
# exponents. We use extended Euclideangm Algorithm to achieve this.

__author__ = 'lucif3r'

import gmpy2
from Crypto.Util.number import long_to_bytes


class RSAModuli:
    def __init__(self):
        self.a = 0
        self.b = 0
        self.m = 0
        self.i = 0
    def gcd(self, num1, num2):
        """
        This function os used to find the GCD of 2 numbers.
        :param num1:
        :param num2:
        :return:
        """
        if num1 < num2:
            num1, num2 = num2, num1
        while num2 != 0:
            num1, num2 = num2, num1 % num2
        return num1
    def extended_euclidean(self, e1, e2):
        """
        The value a is the modular multiplicative inverse of e1 and e2.
        b is calculated from the eqn: (e1*a) + (e2*b) = gcd(e1, e2)
        :param e1: exponent 1
        :param e2: exponent 2
        """
        self.a = gmpy2.invert(e1, e2)
        self.b = (float(self.gcd(e1, e2)-(self.a*e1)))/float(e2)
    def modular_inverse(self, c1, c2, N):
        """
        i is the modular multiplicative inverse of c2 and N.
        i^-b is equal to c2^b. So if the value of b is -ve, we
        have to find out i and then do i^-b.
        Final plain text is given by m = (c1^a) * (i^-b) %N
        :param c1: cipher text 1
        :param c2: cipher text 2
        :param N: Modulus
        """
        i = gmpy2.invert(c2, N)
        mx = pow(c1, self.a, N)
        my = pow(i, int(-self.b), N)
        self.m= mx * my % N
    def print_value(self):
        print("Plain Text: ", self.m)


def main():
    c = RSAModuli()
    N = 13785548242533035810295362602256454972364850762960057993213639634409967747130034619820951379142326426619233273924401584427754675914280656636256283758848187257171620441714405841429766753326859256893428471697505637371133418983711742978119822307382749846578255679304020651279376309342133074648501539860880244710855010635930410693420519839646523060219475991568657729075659395694036124648353882789568153722751340630581251777491037320000691391536936755363483746227385415741441074939489540639489110614921090587504042868195799153203062672211721914333751971690769691480350916962005311018625489584792739407409356523791933995259
    e1 = 65537
    e2 = 75149
    c1 = 13372682938040812010111002886098894637778199388682219726470041240325121846473912302673506707885862070568062367695358339202694043475487547628345131264926156050566034208078584609214764780886953263142273988866509741792777458337591621997834059256305704127337080481822939417779372033730419875596700298115509568842437576343670116787902119267029022049341209195781382151701160443138683136275273296657786188108525207547621123362732390997376245021240225432377695289319168021673201618941441194875284306716186497229355089937471587121782252527697609609723705170346122624068855257291187283680041730706910772098865043504803267434747
    c2 = 7802667066438795675114835445636640428321149860922514083947285327952001671880602046038950080393245447921624382606896470083925259373330671253068760837113100787891851625656222765443097072000657059719866786223750721553560482273240893687456018465580798441620240430485913894061902101703843085920619931415444916970555867569738542387780987383238459406965088835067732356321537063481882337480585151296320464815103179069229748604211201248755674775759044660961861741296460501993440911660923867978742045052099785061882688495804849517476614662934211231716736273762852718944817877920610091094584063956047327156789158106609459974384
    c.extended_euclidean(e1, e2)
    c.modular_inverse(c1, c2, N)
    # c.print_value()
    print(long_to_bytes(c.m).decode('ascii'))


if __name__ == '__main__':
    main()